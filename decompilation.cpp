/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
__int64 sub_400B90();
// void free(void *ptr);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// void srandom(unsigned int seed);
// void __noreturn _exit(int status);
// int system(const char *command);
// int dup(int fd);
// void *memset(void *s, int c, size_t n);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *sbrk(intptr_t delta);
// int fprintf(FILE *stream, const char *format, ...);
// time_t time(time_t *timer);
// __int64 random(void);
// void __noreturn pthread_exit(void *retval);
// void *malloc(size_t size);
// int fflush(FILE *stream);
// void *realloc(void *ptr, size_t size);
// FILE *fdopen(int fd, const char *modes);
// int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count);
// int pthread_barrier_destroy(pthread_barrier_t *barrier);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int pthread_join(pthread_t th, void **thread_return);
// __int64 __fastcall __cxa_atexit(_QWORD, _QWORD, _QWORD); weak
// int getpagesize(void);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int pthread_barrier_wait(pthread_barrier_t *barrier);
// __pid_t fork(void);
// int usleep(__useconds_t useconds);
signed __int64 sub_400DA0();
signed __int64 sub_400E20();
__int64 sub_400E40();
__int64 MassouIsBack();
__int64 PoweredBySix();
_BOOL8 __fastcall sub_400E7C(int a1, __int64 a2);
const char *sub_400ED6();
const char *sub_400EE1();
const char *sub_400EEC();
const char *sub_400EF7();
signed __int64 __fastcall sub_400F02(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_400F81(__int64 a1);
signed __int64 __fastcall sub_401085(__int64 a1);
signed __int64 __fastcall sub_4011E7(__int64 a1);
signed __int64 __fastcall sub_4012D3(__int64 a1);
__int64 __fastcall sub_4013F5(__int64 a1);
signed __int64 __fastcall sub_40151E(__int64 a1);
signed __int64 __fastcall sub_40163E(__int64 a1);
__int64 __fastcall sub_40187B(__int64 a1);
signed __int64 __fastcall sub_4019F0(__int64 a1);
signed __int64 __fastcall sub_401A89(int a1);
signed __int64 __fastcall sub_401ACA(__int64 a1);
signed __int64 __fastcall sub_401B64(__int64 a1);
signed __int64 __fastcall sub_401BC4(__int64 a1);
signed __int64 __fastcall sub_401C24(__int64 a1);
__int64 __fastcall sub_401C84(__int64 a1);
void __fastcall __noreturn start_routine(void *a1);
signed __int64 sub_401E3B();
void __noreturn sub_401EFB();
int __fastcall main(__int64 a1, char **a2, char **a3);
int __fastcall sub_40243F(signed int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int stream);
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_402670(__int64 a1);
void term_proc();
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *off_603DE8[2])() = { &sub_400E40, &sub_400E20 }; // weak
__int64 (__fastcall *off_603DF0)() = &sub_400E20; // weak
__int64 (*qword_604010)(void) = NULL; // weak
_UNKNOWN unk_604108; // weak
_UNKNOWN unk_604110; // weak
_UNKNOWN unk_604117; // weak
FILE *stderr; // idb
char byte_604128; // weak
__int64 qword_604130; // weak


//----- (0000000000400B78) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 604228: using guessed type __int64 _gmon_start__(void);

//----- (0000000000400B90) ----------------------------------------------------
__int64 sub_400B90()
{
  return qword_604010();
}
// 604010: using guessed type __int64 (*qword_604010)(void);

//----- (0000000000400D70) ----------------------------------------------------
#error "400D76: positive sp value has been found (funcsize=3)"

//----- (0000000000400DA0) ----------------------------------------------------
signed __int64 sub_400DA0()
{
  signed __int64 result; // rax

  result = &unk_604117 - &unk_604110;
  if ( (unsigned __int64)(&unk_604117 - &unk_604110) > 0xE )
    result = 0;
  return result;
}

//----- (0000000000400E20) ----------------------------------------------------
signed __int64 sub_400E20()
{
  signed __int64 result; // rax

  if ( !byte_604128 )
  {
    result = sub_400DA0();
    byte_604128 = 1;
  }
  return result;
}
// 604128: using guessed type char byte_604128;

//----- (0000000000400E40) ----------------------------------------------------
__int64 sub_400E40()
{
  return 0;
}

//----- (0000000000400E66) ----------------------------------------------------
__int64 MassouIsBack()
{
  return 0;
}

//----- (0000000000400E71) ----------------------------------------------------
__int64 PoweredBySix()
{
  return 0;
}

//----- (0000000000400E7C) ----------------------------------------------------
_BOOL8 __fastcall sub_400E7C(int a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = (*(__int64 (**)(void))(a2 + 8 * a1))();
  fprintf(*(FILE **)(a2 + 64), " => %s\n", v2);
  return a1 > 0;
}

//----- (0000000000400ED6) ----------------------------------------------------
const char *sub_400ED6()
{
  return ":(";
}

//----- (0000000000400EE1) ----------------------------------------------------
const char *sub_400EE1()
{
  return ":|";
}

//----- (0000000000400EEC) ----------------------------------------------------
const char *sub_400EEC()
{
  return ":)";
}

//----- (0000000000400EF7) ----------------------------------------------------
const char *sub_400EF7()
{
  return "<3";
}

//----- (0000000000400F02) ----------------------------------------------------
signed __int64 __fastcall sub_400F02(__int64 a1, __int64 a2)
{
  if ( (unsigned __int64)(a2 - *(_QWORD *)(a1 + 32)) % *(_QWORD *)(a1 + 40) )
    return 1;
  if ( (unsigned __int64)(a2 - *(_QWORD *)(a1 + 32)) / *(_QWORD *)(a1 + 40) > 2 )
    return 2;
  return 3;
}

//----- (0000000000400F81) ----------------------------------------------------
signed __int64 __fastcall sub_400F81(__int64 a1)
{
  signed __int64 result; // rax
  void *v2; // [rsp+10h] [rbp-10h]
  void *s; // [rsp+18h] [rbp-8h]
  void *sa; // [rsp+18h] [rbp-8h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Testing lil malloc/free and big malloc/free", 1, 0x2, *(FILE **)(a1 + 64));
  s = malloc(0x2);
  if ( !s )
    return 0;
  memset(s, 0, 0x2);
  free(s);
  sa = malloc(0x163);
  if ( !sa )
    return 0;
  memset(sa, 0, 0x163);
  free(sa);
  v2 = sbrk(0);
  if ( *(void **)(a1 + 32) == v2 )
    result = 2;
  else
    result = sub_400F02(a1, (__int64)v2);
  return result;
}

//----- (0000000000401085) ----------------------------------------------------
signed __int64 __fastcall sub_401085(__int64 a1)
{
  signed __int64 result; // rax
  void *ptr; // [rsp+18h] [rbp-8h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Testing very big malloc/free", 1, 0x1, *(FILE **)(a1 + 64));
  ptr = malloc(500000);
  if ( !ptr )
    return 0;
  if ( sbrk(0) == *(void **)(a1 + 32) )
  {
    free(ptr);
    fwrite("\nWARNING: Allocating memory without using sbrk() is forbidden.\n", 1, 0x3, *(FILE **)(a1 + 64));
    result = 0;
  }
  else if ( ((_QWORD)sbrk(0) - *(_QWORD *)(a1 + 32)) % *(_QWORD *)(a1 + 40) )
  {
    free(ptr);
    result = 1;
  }
  else
  {
    free(ptr);
    if ( ((_QWORD)sbrk(0) - *(_QWORD *)(a1 + 32)) / *(_QWORD *)(a1 + 40) > 2 )
      result = 2;
    else
      result = 3;
  }
  return result;
}

//----- (00000000004011E7) ----------------------------------------------------
signed __int64 __fastcall sub_4011E7(__int64 a1)
{
  void *v2; // [rsp+18h] [rbp-8h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  *(_QWORD *)(a1 + 32) = sbrk(0);
  fwrite("Testing very lil malloc/free", 1, 0x1, *(FILE **)(a1 + 64));
  *(_QWORD *)(a1 + 48) = malloc(2);
  if ( !*(_QWORD *)(a1 + 48) )
    return 0;
  v2 = sbrk(0);
  if ( *(void **)(a1 + 32) == v2 )
    return 3;
  if ( ((_QWORD)v2 - *(_QWORD *)(a1 + 32)) % *(_QWORD *)(a1 + 40) )
    return 1;
  return 2LL;
}

//----- (00000000004012D3) ----------------------------------------------------
signed __int64 __fastcall sub_4012D3(__int64 a1)
{
  int v1; // ebx
  void *ptr[12]; // [rsp+10h] [rbp-80h]
  void *v4; // [rsp+70h] [rbp-20h]
  int v5; // [rsp+78h] [rbp-18h]
  int i; // [rsp+7Ch] [rbp-14h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Testing pow(2) malloc's/free's", 1, 0x1, *(FILE **)(a1 + 64));
  *(_QWORD *)(a1 + 32) = sbrk(0);
  v5 = 0;
  for ( i = 1; i <= 2047; i *= 2 )
  {
    v1 = v5++;
    ptr[v1] = malloc(i);
    if ( !ptr[v1] )
      break;
  }
  if ( i != 2048 )
    return 0;
  while ( --v5 >= 0 )
    free(ptr[v5]);
  v4 = sbrk(0);
  return sub_400F02(a1, (__int64)v4);
}

//----- (00000000004013F5) ----------------------------------------------------
__int64 __fastcall sub_4013F5(__int64 a1)
{
  void *ptr; // ST28_8
  void *v2; // ST28_8
  _BYTE *v4; // [rsp+10h] [rbp-30h]
  _BYTE *v5; // [rsp+18h] [rbp-28h]
  _BYTE *v6; // [rsp+20h] [rbp-20h]
  _BYTE *v7; // [rsp+30h] [rbp-10h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  v8 = 0;
  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Test 4 : Testing pagesize malloc's/free's", 1, 0x29, *(FILE **)(a1 + 64));
  v7 = sbrk(0);
  ptr = malloc(3 * *(_QWORD *)(a1 + 40));
  v6 = sbrk(0);
  free(ptr);
  v5 = sbrk(0);
  v2 = malloc(*(_QWORD *)(a1 + 40));
  v4 = sbrk(0);
  free(v2);
  if ( v6 == v7 )
    return 0;
  if ( v6 > v5 )
    v8 = 1;
  if ( (unsigned __int64)(v5 - v7) / *(_QWORD *)(a1 + 40) <= 2 )
    ++v8;
  if ( v4 == v5 )
    ++v8;
  return v8;
}

//----- (000000000040151E) ----------------------------------------------------
signed __int64 __fastcall sub_40151E(__int64 a1)
{
  int v1; // ebx
  int v3; // eax
  void *ptr[1001]; // [rsp+10h] [rbp-1F70h]
  void *v5; // [rsp+1F58h] [rbp-28h]
  int v6; // [rsp+1F64h] [rbp-1Ch]
  int v7; // [rsp+1F68h] [rbp-18h]
  int i; // [rsp+1F6Ch] [rbp-14h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Test 5 : Testing hundred of pow(2) malloc's/free's", 1, 0x32, *(FILE **)(a1 + 64));
  v7 = 0;
  v6 = 0;
  while (1)
  {
    v3 = v6++;
    if ( v3 > 99 )
      break;
    for ( i = 1; i <= 1023; i *= 2 )
    {
      v1 = v7++;
      ptr[v1] = malloc(i);
      if ( !ptr[v1] )
        return 0LL;
    }
  }
  while ( --v7 >= 0 )
    free(ptr[v7]);
  v5 = sbrk(0);
  return sub_400F02(a1, (__int64)v5);
}

//----- (000000000040163E) ----------------------------------------------------
signed __int64 __fastcall sub_40163E(__int64 a1)
{
  int v1; // ebx
  int v3; // eax
  int v4; // eax
  void *ptr[1002]; // [rsp+10h] [rbp-1F80h]
  char *v6; // [rsp+1F60h] [rbp-30h]
  int v7; // [rsp+1F68h] [rbp-28h]
  int v8; // [rsp+1F6Ch] [rbp-24h]
  int v9; // [rsp+1F70h] [rbp-20h]
  int i; // [rsp+1F74h] [rbp-1Ch]
  char *v11; // [rsp+1F78h] [rbp-18h]

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Test 6 : Testing alternate lil/big malloc's", 1, 0x2, *(FILE **)(a1 + 64));
  v6 = (char *)sbrk(0);
  v11 = v6;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  while ( 1 )
  {
    v3 = v8++;
    if ( v3 > 99 )
      break;
    for ( i = 1; i <= 1023; i *= 2 )
    {
      v1 = v9++;
      ptr[v1] = malloc(i);
      if ( !ptr[v1] )
        return 0;
    }
    if ( &v11[-2 * *(_QWORD *)(a1 + 40)] <= &v6[*(_QWORD *)(a1 + 40) * (v8 - 1)]
      && &v6[*(_QWORD *)(a1 + 40) * (v8 - 1)] <= v11 )
    {
      ++v7;
    }
    v11 = (char *)sbrk(0);
  }
  --v9;
  while ( v9 >= 0 )
  {
    v4 = v9--;
    free(ptr[v4]);
  }
  v11 = (char *)sbrk(0);
  if ( (unsigned __int64)&v11[-*(_QWORD *)(a1 + 32)] % *(_QWORD *)(a1 + 40) || v7 <= 0 )
    return 1;
  if ( (unsigned __int64)&v11[-*(_QWORD *)(a1 + 32)] / *(_QWORD *)(a1 + 40) > 2 )
    return 2;
  if ( --v8 != v7 )
    return 2;
  return 3;
}

//----- (000000000040187B) ----------------------------------------------------
__int64 __fastcall sub_40187B(__int64 a1)
{
  __int64 v1; // ST08_8
  void *v3; // rax
  int v4; // eax
  void *v5; // ST28_8
  void *v6; // [rsp+18h] [rbp-28h]
  void *v7; // [rsp+20h] [rbp-20h]
  void *ptr; // [rsp+28h] [rbp-18h]
  void *ptra; // [rsp+28h] [rbp-18h]
  void *ptrb; // [rsp+28h] [rbp-18h]
  size_t size; // [rsp+30h] [rbp-10h]
  unsigned int v12; // [rsp+3Ch] [rbp-4h]

  v1 = a1;
  size = 42 * getpagesize();
  ++*(_DWORD *)(v1 + 56);
  *(_DWORD *)(v1 + 76) += 3;
  fwrite("Test 7 : Testing realloc's", 1, 0x1, *(FILE **)(a1 + 64));
  ptr = realloc(0, 2);
  if ( !ptr )
    return 0;
  ptra = realloc(ptr, size);
  if ( !ptra )
    return 0;
  v3 = memset(ptra, 0, size);
  realloc(v3, 0);
  v12 = 1;
  v4 = getpagesize();
  v5 = realloc(0, v4 + size);
  v7 = v5;
  v6 = sbrk(0);
  ptrb = realloc(v5, 0x1F4);
  if ( !ptrb )
    return 0;
  if ( v7 == ptrb )
    v12 = 2;
  if ( sbrk(0) == v6 )
    ++v12;
  realloc(ptrb, 0);
  return v12;
}

//----- (00000000004019F0) ----------------------------------------------------
signed __int64 __fastcall sub_4019F0(__int64 a1)
{
  void *v2; // rax

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 3;
  fwrite("Test 9 : Various Dumb Tests...", 1, 0x1E, *(FILE **)(a1 + 64));
  if ( !malloc(0) )
    return 0;
  if ( malloc(0xFFFFFFFFFFFFFFF) )
    return 0;
  v2 = sbrk(0);
  return sub_400F02(a1, (__int64)v2);
}

//----- (0000000000401A89) ----------------------------------------------------
signed __int64 __fastcall sub_401A89(int a1)
{
  if ( (char)((char)((a1 & 0x7F) + 1) >> 1) > 0 )
    return 0;
  if ( a1 != -1 && BYTE1(a1) != 139 )
    return 2;
  return 0;
}

//----- (0000000000401ACA) ----------------------------------------------------
signed __int64 __fastcall sub_401ACA(__int64 a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  signed __int64 result; // rax

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 2;
  fwrite("Test Exec 0 : Testing standard ls test's", 1uLL, 0x28uLL, *(FILE **)(a1 + 64));
  v1 = system("ls > /dev/null");
  if ( (unsigned int)sub_401A89(v1)
    && (v2 = system("ls -l > /dev/null"), (unsigned int)sub_401A89(v2))
    && (v3 = system("ls -l /home > /dev/null"), (unsigned int)sub_401A89(v3)) )
  {
    result = 2;
  }
  else
  {
    result = 2;
  }
  return result;
}

//----- (0000000000401B64) ----------------------------------------------------
signed __int64 __fastcall sub_401B64(__int64 a1)
{
  int v1; // eax

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 2;
  fwrite("Test Exec 1 : Testing ls -lRa /tmp", 1, 0x22, *(FILE **)(a1 + 64));
  v1 = system("ls -lRa /tmp > /dev/null");
  return sub_401A89(v1);
}

//----- (0000000000401BC4) ----------------------------------------------------
signed __int64 __fastcall sub_401BC4(__int64 a1)
{
  int v1; // eax

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 2;
  fwrite("Test Exec 2 : Testing ls -lRa /home", 1, 0x23, *(FILE **)(a1 + 64));
  v1 = system("ls -lRa /home > /dev/null");
  return sub_401A89(v1);
}

//----- (0000000000401C24) ----------------------------------------------------
signed __int64 __fastcall sub_401C24(__int64 a1)
{
  int v1; // eax

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 2;
  fwrite("Test Exec 3 : Testing ls -lRa /dev", 1, 0x22, *(FILE **)(a1 + 64));
  v1 = system("ls -lRa /dev > /dev/null");
  return sub_401A89(v1);
}

//----- (0000000000401C84) ----------------------------------------------------
__int64 __fastcall sub_401C84(__int64 a1)
{
  int v1; // eax
  unsigned int v2; // ST1C_4

  ++*(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 76) += 2;
  fwrite("Test Exec 4 : Testing bc", 1, 0x18, *(FILE **)(a1 + 64));
  system("echo \"42+42\nquit\" > /tmp/calc");
  v1 = system("bc < /tmp/calc > /dev/null");
  v2 = sub_401A89(v1);
  system("rm -rf /tmp/calc");
  return v2;
}

//----- (0000000000401CFE) ----------------------------------------------------
void __fastcall __noreturn start_routine(void *a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  void *ptr[1001]; // [rsp+10h] [rbp-1F50h]
  int i; // [rsp+1F5Ch] [rbp-4h]

  pthread_barrier_wait((pthread_barrier_t *)a1);
  for ( i = 0; i <= 999; ++i )
  {
    v1 = random();
    ptr[i] = malloc(v1 % 4096);
    if ( !ptr[i] )
      pthread_exit(0);
  }
  --i;
  while ( i >= 0 )
    free(ptr[i--]);
  for ( i = 0; i <= 999; ++i )
  {
    v2 = random();
    ptr[i] = malloc(v2 % 4096);
    if ( !ptr[i] )
      pthread_exit(0);
    free(ptr[i]);
  }
  pthread_exit((void *)2);
}

//----- (0000000000401E3B) ----------------------------------------------------
signed __int64 sub_401E3B()
{
  unsigned int v0; // eax
  void *thread_return; // [rsp+8h] [rbp-B8h]
  pthread_t th[16]; // [rsp+10h] [rbp-B0h]
  pthread_barrier_t barrier; // [rsp+90h] [rbp-30h]
  int i; // [rsp+BCh] [rbp-4h]

  v0 = time(0);
  srandom(v0);
  pthread_barrier_init(&barrier, 0, 0x10);
  for ( i = 0; i <= 15; ++i )
  {
    if ( pthread_create(&th[i], 0LL, (void *(*)(void *))start_routine, &barrier) )
      return 0;
  }
  for ( i = 0; i <= 15; ++i )
    pthread_join(th[i], &thread_return);
  pthread_barrier_destroy(&barrier);
  return 3;
}
// 401E3B: using guessed type pthread_t th[16];

//----- (0000000000401EFB) ----------------------------------------------------
void __noreturn sub_401EFB()
{
  _exit(0);
}

//----- (0000000000401FD4) ----------------------------------------------------
int __fastcall main(__int64 a1, char **a2, char **a3)
{
  int v3; // eax
  float v4; // xmm0_4
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v16; // eax
  signed __int64 (__fastcall *v17)(__int64); // [rsp+10h] [rbp-C0h]
  signed __int64 (__fastcall *v18)(__int64); // [rsp+18h] [rbp-B8h]
  signed __int64 (__fastcall *v19)(__int64); // [rsp+20h] [rbp-B0h]
  signed __int64 (__fastcall *v20)(__int64); // [rsp+28h] [rbp-A8h]
  __int64 (__fastcall *v21)(__int64); // [rsp+30h] [rbp-A0h]
  signed __int64 (__fastcall *v22)(__int64); // [rsp+38h] [rbp-98h]
  signed __int64 (__fastcall *v23)(__int64); // [rsp+40h] [rbp-90h]
  __int64 (__fastcall *v24)(__int64); // [rsp+48h] [rbp-88h]
  signed __int64 (__fastcall *v25)(__int64); // [rsp+50h] [rbp-80h]
  char buf; // [rsp+5Bh] [rbp-75h]
  int stat_loc; // [rsp+5Ch] [rbp-74h]
  const char *(*v28)(); // [rsp+60h] [rbp-70h]
  const char *(*v29)(); // [rsp+68h] [rbp-68h]
  const char *(*v30)(); // [rsp+70h] [rbp-60h]
  const char *(*v31)(); // [rsp+78h] [rbp-58h]
  void *v32; // [rsp+80h] [rbp-50h]
  __int64 v33; // [rsp+88h] [rbp-48h]
  void *ptr; // [rsp+90h] [rbp-40h]
  int v35; // [rsp+98h] [rbp-38h]
  FILE *s; // [rsp+A0h] [rbp-30h]
  int v37; // [rsp+A8h] [rbp-28h]
  int v38; // [rsp+ACh] [rbp-24h]
  float v39; // [rsp+B0h] [rbp-20h]
  int v40; // [rsp+B4h] [rbp-1Ch]
  __pid_t pid; // [rsp+C4h] [rbp-Ch]
  int v42; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  v28 = sub_400ED6;
  v29 = sub_400EE1;
  v30 = sub_400EEC;
  v31 = sub_400EF7;
  v32 = sbrk(0);
  v33 = getpagesize();
  ptr = 0;
  v35 = 0;
  v3 = dup(2);
  s = fdopen(v3, "a+");
  v37 = 0;
  v38 = 0;
  v39 = 0.0;
  v40 = 0;
  v17 = sub_400F81;
  v18 = sub_401085;
  v19 = sub_4011E7;
  v20 = sub_4012D3;
  v21 = sub_4013F5;
  v22 = sub_40151E;
  v23 = sub_40163E;
  v24 = sub_40187B;
  v25 = sub_4019F0;
  qword_604130 = (__int64)&v28;
  fwrite(
    "Legend... :\n:( => NOK\n:| => BOF\n:) => GOOD\n<3 => VERY GOOD\nAry :)\nBy Six && Massou\n\n",
    1,
    0x54,
    s);
  close(2);
  for ( i = 0; i <= 7; ++i )
  {
    v42 = (*(&v17 + i))((__int64)&v28);
    if ( v42 > 0 )
      ++v40;
    v4 = (double)v42 * 0.25 + v39;
    v39 = v4;
    if ( i == 3 )
      free(ptr);
    v37 += v42;
    sub_400E7C(v42, (__int64)&v28);
  }
  v5 = sub_401ACA((__int64)&v28);
  v6 = sub_400E7C(v5, (__int64)&v28);
  v40 += v6;
  if ( v40 )
    v39 = v39 + 0.5;
  i = 0;
  v7 = sub_401B64((__int64)&v28);
  v8 = sub_400E7C(v7, (__int64)&v28);
  v40 += v8;
  if ( v40 )
    ++i;
  v9 = sub_401BC4((__int64)&v28);
  v10 = sub_400E7C(v9, (__int64)&v28);
  v40 += v10;
  if ( v40 )
    ++i;
  v11 = sub_401C24((__int64)&v28);
  v12 = sub_400E7C(v11, (__int64)&v28);
  v40 += v12;
  if ( v40 )
    ++i;
  switch ( i )
  {
    case 1:
      v39 = v39 + 0.25;
      break;
    case 2:
      v39 = v39 + 0.5;
      break;
    case 3:
      v39 = v39 + 1.0;
      break;
  }
  v13 = sub_401C84((__int64)&v28);
  v14 = sub_400E7C(v13, (__int64)&v28);
  v40 += v14;
  if ( v40 )
    v39 = v39 + 0.5;
  fwrite("Launch Threads Test?? Y/N (N)\n", 1, 0x1, s);
  read(0, &buf, 1);
  if ( buf != 121 && buf != 89 )
LABEL_37:
    exit(0);
  pid = fork();
  if ( pid != -1 )
  {
    if ( !pid )
    {
      sub_402670((__int64)sub_401EFB);
      v16 = sub_401E3B();
      exit(v16);
    }
    ++v35;
    v38 += 3;
    fwrite("Test Threads 0 : Testing multi-thread's", 1, 0x27, s);
    fflush(s);
    while ( !waitpid(pid, &stat_loc, 1) )
      usleep(0xA);
    if ( (unsigned int)sub_401A89(stat_loc) )
    {
      sub_400E7C(3, (__int64)&v28);
      ++v40;
    }
    else
    {
      sub_400E7C(0, (__int64)&v28);
    }
    goto LABEL_37;
  }
  return fprintf(s, "Unable to fork...\n", a2);
}
// 604130: using guessed type __int64 qword_604130;

//----- (000000000040243F) ----------------------------------------------------
int __fastcall sub_40243F(signed int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int stream)
{
  int v15; // eax
  int v17; // eax
  int stat_loc; // [rsp+1Ch] [rbp-84h]
  signed __int64 (__fastcall *v19)(__int64); // [rsp+20h] [rbp-80h]
  signed __int64 (__fastcall *v20)(__int64); // [rsp+28h] [rbp-78h]
  signed __int64 (__fastcall *v21)(__int64); // [rsp+30h] [rbp-70h]
  signed __int64 (__fastcall *v22)(__int64); // [rsp+38h] [rbp-68h]
  __int64 (__fastcall *v23)(__int64); // [rsp+40h] [rbp-60h]
  signed __int64 (__fastcall *v24)(__int64); // [rsp+48h] [rbp-58h]
  signed __int64 (__fastcall *v25)(__int64); // [rsp+50h] [rbp-50h]
  __int64 (__fastcall *v26)(__int64); // [rsp+58h] [rbp-48h]
  signed __int64 (__fastcall *v27)(__int64); // [rsp+60h] [rbp-40h]
  signed __int64 (__fastcall *v28)(__int64); // [rsp+68h] [rbp-38h]
  signed __int64 (__fastcall *v29)(__int64); // [rsp+70h] [rbp-30h]
  signed __int64 (__fastcall *v30)(__int64); // [rsp+78h] [rbp-28h]
  signed __int64 (__fastcall *v31)(__int64); // [rsp+80h] [rbp-20h]
  __int64 (__fastcall *v32)(__int64); // [rsp+88h] [rbp-18h]
  __pid_t pid; // [rsp+9Ch] [rbp-4h]

  v19 = sub_400F81;
  v20 = sub_401085;
  v21 = sub_4011E7;
  v22 = sub_4012D3;
  v23 = sub_4013F5;
  v24 = sub_40151E;
  v25 = sub_40163E;
  v26 = sub_40187B;
  v27 = sub_4019F0;
  v28 = sub_401ACA;
  v29 = sub_401B64;
  v30 = sub_401BC4;
  v31 = sub_401C24;
  v32 = sub_401C84;
  if ( a1 < 1 )
  {
LABEL_17:
    fprintf(stderr, "ERROR: Unkown test %d\n", (unsigned int)a1);
    exit(0);
  }
  if ( a1 <= 14 )
  {
    v15 = (*(&v19 + a1 - 1))((__int64)&a7);
    sub_400E7C(v15, (__int64)&a7);
  }
  else
  {
    if ( a1 != 15 )
      goto LABEL_17;
    pid = fork();
    if ( pid == -1 )
      return fprintf(stderr, "Unable to fork...\n");
    if ( !pid )
    {
      sub_402670((__int64)sub_401EFB);
      v17 = sub_401E3B();
      exit(v17);
    }
    fflush(*(FILE **)&stream);
    while ( !waitpid(pid, &stat_loc, 1) )
      usleep(0xAu);
    if ( (unsigned int)sub_401A89(stat_loc) )
      sub_400E7C(3, (__int64)&a7);
    else
      sub_400E7C(0, (__int64)&a7);
  }
  return 1;
}

//----- (00000000004025F0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  v4 = &off_603DF0 - off_603DE8;
  init_proc();
  if ( v4 )
  {
    v5 = 0;
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_603DE8[v5++])(a1, a2, v3);
    while ( v4 != v5 );
  }
}
// 603DE8: using guessed type __int64 (__fastcall *off_603DE8[2])();
// 603DF0: using guessed type __int64 (__fastcall *off_603DF0)();

//----- (0000000000402670) ----------------------------------------------------
__int64 __fastcall sub_402670(__int64 a1)
{
  __int64 result; // rax

  if ( &unk_604108 )
    result = __cxa_atexit(a1, 0LL, unk_604108);
  else
    result = __cxa_atexit(a1, 0, 0);
  return result;
}
// 400D00: using guessed type __int64 __fastcall __cxa_atexit(_QWORD, _QWORD, _QWORD);

//----- (000000000040269C) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 37 function(s)"
